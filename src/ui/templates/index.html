{% extends "base.html" %}

{% block content %}
<div class="main-layout">
    <!-- Left Sidebar with Stats -->
    <div class="sidebar">
        <!-- Action Buttons -->
        <div class="action-buttons">
            <button onclick="fetchJobEmails()" class="action-btn fetch-emails">
                Fetch Jobs from Email
            </button>
            <button onclick="window.location.href='/add_job_by_url'" class="action-btn add-by-url">
                Add Job by URL
            </button>
            <button onclick="window.location.href='/manually_enter'" class="action-btn manual-entry">
                Manually Enter Jobs in Form
            </button>
        </div>
        
        <!-- Stats Cards -->
        <div class="stats-sidebar">
            <a href="/phase/queued" class="stat-card-sidebar {% if current_phase == 'queued' %}active{% endif %}">
                <div class="stat-number">{{ "%02d"|format(phase_counts.queued) }}</div>
                <div class="stat-label">Queued</div>
            </a>
            
            <button onclick="processQueue()" class="process-queue-btn">
                <div class="process-icon">‚öôÔ∏è</div>
                <div class="process-text">Process All Jobs in Queue</div>
            </button>
            
            <a href="/phase/generated" class="stat-card-sidebar {% if current_phase == 'generated' %}active{% endif %}">
                <div class="stat-number">{{ "%02d"|format(phase_counts.generated) }}</div>
                <div class="stat-label">Generated</div>
            </a>
            
            <a href="/phase/applied" class="stat-card-sidebar {% if current_phase == 'applied' %}active{% endif %}">
                <div class="stat-number">{{ "%02d"|format(phase_counts.applied) }}</div>
                <div class="stat-label">Applied</div>
            </a>
            
            <a href="/phase/communications" class="stat-card-sidebar {% if current_phase == 'communications' %}active{% endif %}">
                <div class="stat-number">{{ "%02d"|format(phase_counts.communications) }}</div>
                <div class="stat-label">In Comms</div>
            </a>
            
            <a href="/phase/interviews" class="stat-card-sidebar {% if current_phase == 'interviews' %}active{% endif %}">
                <div class="stat-number">{{ "%02d"|format(phase_counts.interviews) }}</div>
                <div class="stat-label">Interviewing</div>
            </a>
            
            <a href="/phase/errors" class="stat-card-sidebar {% if current_phase == 'errors' %}active{% endif %}">
                <div class="stat-number">{{ "%02d"|format(phase_counts.errors) }}</div>
                <div class="stat-label">Errored</div>
            </a>
            
            <a href="/phase/expired" class="stat-card-sidebar {% if current_phase == 'expired' %}active{% endif %}">
                <div class="stat-number">{{ "%02d"|format(phase_counts.expired) }}</div>
                <div class="stat-label">Expired</div>
            </a>
            
            <a href="/phase/skipped" class="stat-card-sidebar {% if current_phase == 'skipped' %}active{% endif %}">
                <div class="stat-number">{{ "%02d"|format(phase_counts.skipped) }}</div>
                <div class="stat-label">Skipped</div>
            </a>
        </div>
    </div>
    
    <!-- Main Content Area -->
    <div class="main-content">
        <h2 class="content-title">{{ current_phase.title() }} Jobs</h2>
        
        {% if folders %}
            <!-- Job Cards Grid -->
            <div class="job-grid">
                {% for folder in folders %}
                    <div class="job-card {% if folder.job_data.date_received and calculate_days_old(folder.job_data.date_received) <= 3 %}recent{% endif %}">
                        
                        <!-- Company & Job Title -->
                        <div class="job-header">
                            <h3 class="company-name">
                                <a href="/job/{{ folder.name }}">
                                    {% if folder.job_data.company %}{{ folder.job_data.company }}{% else %}Acme Company{% endif %}
                                </a>
                            </h3>
                            <div class="job-title">
                                {% if folder.job_data.title %}{{ folder.job_data.title }}{% else %}Director of Solution Engineering{% endif %}
                            </div>
                        </div>
                        
                        <!-- Job Metadata -->
                        <div class="job-meta">
                            {% if folder.job_data.date_received %}
                                <div class="job-meta-item">Received {{ calculate_days_old(folder.job_data.date_received) }} days ago</div>
                            {% else %}
                                <div class="job-meta-item">Received 8 days ago</div>
                            {% endif %}
                            {% if folder.job_data.location %}
                                <div class="job-meta-item">{{ folder.job_data.location }}</div>
                            {% else %}
                                <div class="job-meta-item">United States (Remote)</div>
                            {% endif %}
                            {% if folder.job_data.salary %}
                                <div class="job-meta-item">{{ folder.job_data.salary }}</div>
                            {% else %}
                                <div class="job-meta-item">$241K - $394K / year</div>
                            {% endif %}
                            <div class="job-meta-item phase-info">Phase: Generated</div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div class="job-actions">
                            {% if current_phase == 'generated' %}
                                <div class="action-row">
                                    {% if folder.file_exists.resume %}
                                        <a href="/view_custom_file/{{ folder.name }}/resume" class="btn btn-primary" target="_blank">
                                            View Resume
                                        </a>
                                        {% if folder.file_exists.resume_pdf %}
                                            <a href="/view_pdf/{{ folder.name }}/resume" class="btn btn-pdf" target="_blank">
                                                PDF
                                            </a>
                                        {% else %}
                                            <span class="btn btn-pdf btn-disabled">PDF</span>
                                        {% endif %}
                                    {% else %}
                                        <span class="btn btn-primary btn-disabled">View Resume</span>
                                        <span class="btn btn-pdf btn-disabled">PDF</span>
                                    {% endif %}
                                </div>
                                <div class="action-row">
                                    {% if folder.file_exists.coverletter %}
                                        <a href="/view_custom_file/{{ folder.name }}/coverletter" class="btn btn-primary" target="_blank">
                                            View Cover Letter
                                        </a>
                                        {% if folder.file_exists.coverletter_pdf %}
                                            <a href="/view_pdf/{{ folder.name }}/coverletter" class="btn btn-pdf" target="_blank">
                                                PDF
                                            </a>
                                        {% else %}
                                            <span class="btn btn-pdf btn-disabled">PDF</span>
                                        {% endif %}
                                    {% else %}
                                        <span class="btn btn-primary btn-disabled">View Cover Letter</span>
                                        <span class="btn btn-pdf btn-disabled">PDF</span>
                                    {% endif %}
                                </div>
                                <div class="action-row">
                                    {% if folder.file_exists.summary %}
                                        <a href="/view_summary/{{ folder.name }}" class="btn btn-secondary" target="_blank">
                                            View Job Summary
                                        </a>
                                    {% else %}
                                        <span class="btn btn-secondary btn-disabled">View Job Summary</span>
                                    {% endif %}
                                </div>
                            {% else %}
                                <div class="action-row">
                                    <a href="/job/{{ current_phase }}/{{ folder.name }}" class="btn btn-secondary">
                                        View Details
                                    </a>
                                </div>
                                {% if current_phase == 'queued' %}
                                    <div class="action-row">
                                        <button onclick="processJob('{{ folder.name }}')" class="btn btn-success">
                                            Generate Resume
                                        </button>
                                    </div>
                                {% endif %}
                            {% endif %}
                        </div>
                        
                        <!-- Actions Dropdown -->
                        <div class="job-actions-dropdown">
                            <div class="actions-label">Actions:</div>
                            <div class="dropdown">
                                <button class="btn dropdown-toggle">
                                    -- Available Actions -- ‚ñº
                                </button>
                                <div class="dropdown-menu">
                                    <button class="dropdown-item" onclick="skipJob('{{ folder.name }}')">
                                        Skip this Job / Not Applicable
                                    </button>
                                    <button class="dropdown-item" onclick="markApplied('{{ folder.name }}')">
                                        Mark as "Applied"
                                    </button>
                                    <button class="dropdown-item" onclick="markCommunications('{{ folder.name }}')">
                                        Mark as "In Communications"
                                    </button>
                                    <button class="dropdown-item" onclick="markInterviewing('{{ folder.name }}')">
                                        Mark as "Interviewing"
                                    </button>
                                    <button class="dropdown-item" onclick="markExpired('{{ folder.name }}')">
                                        Mark as "Expired"
                                    </button>
                                    <button class="dropdown-item" onclick="resetToQueued('{{ folder.name }}')">
                                        Send back to "Queue"
                                    </button>
                                    <button class="dropdown-item" onclick="regenerateJob('{{ folder.name }}')">
                                        ü§ñ Regenerate AI Resume/Letter
                                    </button>
                                    <button class="dropdown-item" onclick="regenerateHtmlOnly('{{ folder.name }}')">
                                        üîÑ Regenerate HTML Only
                                    </button>
                                    <button class="dropdown-item" onclick="regenerateJobPdfs('{{ folder.name }}')">
                                        üìÑ Regenerate PDFs
                                    </button>
                                    <a href="/edit_job/{{ current_phase }}/{{ folder.name }}" class="dropdown-item">
                                        Edit Job YAML
                                    </a>
                                    {% if folder.job_data.link %}
                                        <a href="{{ folder.job_data.link }}" target="_blank" class="dropdown-item">
                                            Open Job Link
                                        </a>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                    </div>
                {% endfor %}
            </div>
        {% else %}
            <div class="empty-state">
                <h3>No generated job applications found</h3>
                <p>Run the job generation process to see applications here.</p>
                <a href="/run_step2" class="btn">üöÄ Generate Jobs</a>
            </div>
        {% endif %}
    </div>
</div>

<script>
function markCommunications(folderName) {
    if (confirm('Mark this job as in communications? This will move it to the communications folder.')) {
        fetch('/mark_communications/' + folderName, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showAlert(data.message, 'success');
                setTimeout(() => location.reload(), 1000);
            } else {
                showAlert('Error: ' + data.message, 'error');
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
        });
    }
}

function markInterviewing(folderName) {
    if (confirm('Mark this job as interviewing? This will move it to the interviews folder.')) {
        fetch('/mark_interviewing/' + folderName, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showAlert(data.message, 'success');
                setTimeout(() => location.reload(), 1000);
            } else {
                showAlert('Error: ' + data.message, 'error');
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
        });
    }
}

function markExpired(folderName) {
    if (confirm('Mark this job as expired? This will move it to the expired folder.')) {
        fetch('/mark_expired/' + folderName, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showAlert(data.message, 'success');
                setTimeout(() => location.reload(), 1000);
            } else {
                showAlert('Error: ' + data.message, 'error');
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
        });
    }
}

function regenerateJob(folderName) {
    if (confirm('Regenerate AI resume and cover letter for this job? This may take a few minutes.')) {
        // Get selected resume
        const resumeSelect = document.getElementById('resume-select');
        const selectedResumeValue = resumeSelect ? resumeSelect.value : '';
        
        if (!selectedResumeValue) {
            alert('Please select a resume first.');
            return;
        }
        
        // Create form data to include selected resume
        const formData = new FormData();
        formData.append('selected_resume', selectedResumeValue);
        
        fetch('/regenerate_job/' + folderName, {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Show persistent progress indicator
                showProgressIndicator('AI Regeneration Started', data.message);
                // Start polling for progress
                pollJobRegenerationProgress();
            } else {
                showAlert('Error: ' + data.message, 'error');
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
        });
    }
}

function showProgressIndicator(title, message) {
    const indicator = document.getElementById('progress-indicator');
    const titleEl = document.getElementById('progress-title');
    const messageEl = document.getElementById('progress-message');
    
    if (indicator && titleEl && messageEl) {
        titleEl.textContent = title;
        messageEl.textContent = message;
        indicator.style.display = 'block';
        
        // Scroll to top to make sure user sees it
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
}

function updateProgressIndicator(title, message) {
    const titleEl = document.getElementById('progress-title');
    const messageEl = document.getElementById('progress-message');
    
    if (titleEl && messageEl) {
        titleEl.textContent = title;
        messageEl.textContent = message;
    }
}

function hideProgressIndicator() {
    const indicator = document.getElementById('progress-indicator');
    if (indicator) {
        indicator.style.display = 'none';
    }
}

function pollJobRegenerationProgress() {
    let pollCount = 0;
    const maxPolls = 120; // 4 minutes max (2 second intervals)
    
    function checkProgress() {
        pollCount++;
        
        fetch('/get_job_regeneration_progress')
        .then(response => response.json())
        .then(data => {
            if (data.success && data.progress) {
                const progress = data.progress;
                
                if (progress.status === 'idle') {
                    // No regeneration in progress
                    hideProgressIndicator();
                    return;
                }
                
                // Update the progress indicator
                if (progress.status === 'running' || progress.status === 'starting') {
                    updateProgressIndicator('AI Regeneration In Progress', progress.message);
                    
                    // Continue polling if not completed and under max polls
                    if (!progress.completed && pollCount < maxPolls) {
                        setTimeout(checkProgress, 2000); // Poll every 2 seconds
                    } else if (pollCount >= maxPolls) {
                        updateProgressIndicator('Taking Longer Than Expected', 'Job regeneration is taking longer than expected. Please check back later or refresh the page.');
                        // Don't hide the indicator, let user know it's still running
                    }
                } else if (progress.status === 'completed') {
                    updateProgressIndicator('AI Regeneration Completed!', progress.message + ' Page will reload in 3 seconds.');
                    setTimeout(() => {
                        hideProgressIndicator();
                        location.reload();
                    }, 3000);
                } else if (progress.status === 'error') {
                    updateProgressIndicator('AI Regeneration Failed', 'Error: ' + progress.message);
                    // Keep the error visible for 10 seconds, then hide
                    setTimeout(() => {
                        hideProgressIndicator();
                    }, 10000);
                }
            } else {
                updateProgressIndicator('Progress Check Failed', 'Error checking progress: ' + (data.message || 'Unknown error'));
                setTimeout(() => {
                    hideProgressIndicator();
                }, 5000);
            }
        })
        .catch(error => {
            updateProgressIndicator('Progress Check Failed', 'Error checking progress: ' + error);
            setTimeout(() => {
                hideProgressIndicator();
            }, 5000);
        });
    }
    
    // Start checking progress after a short delay
    setTimeout(checkProgress, 1000);
}

function regenerateHtmlOnly(folderName) {
    if (confirm('Regenerate HTML files (resume + cover letter) from existing content? This will update formatting without calling AI.')) {
        // Show loading message
        showAlert('Regenerating HTML files from existing content...', 'info');
        
        fetch('/regenerate_html_only/' + folderName, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showAlert('HTML files regenerated successfully! ' + (data.message || ''), 'success');
                // Refresh the page to show updated files
                setTimeout(() => {
                    location.reload();
                }, 2000);
            } else {
                showAlert('Error regenerating HTML files: ' + (data.message || 'Unknown error'), 'danger');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            showAlert('Error regenerating HTML files: ' + error.message, 'danger');
        });
    }
}

function regenerateJobPdfs(folderName) {
    if (confirm('Regenerate PDF files for this job? This will replace existing PDFs with new ones generated from the current HTML files.')) {
        // Show loading message
        showAlert('Starting PDF regeneration for this job...', 'success');
        
        fetch('/regenerate_job_pdfs/' + folderName, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showAlert(data.message, 'success');
                setTimeout(() => {
                    window.location.reload();
                }, 2000);
            } else {
                // Handle multi-line error messages
                const errorMessage = data.message.replace(/\n/g, '<br>');
                showAlert('Error: ' + errorMessage, 'error');
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
        });
    }
}

function markApplied(folderName) {
    if (confirm('Mark this job as applied? This will move it to the applied folder.')) {
        fetch('/mark_applied/' + folderName, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showAlert(data.message, 'success');
                setTimeout(() => location.reload(), 1000);
            } else {
                showAlert('Error: ' + data.message, 'error');
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
        });
    }
}

function skipJob(folderName) {
    if (confirm('Skip this job? This will move it to the skipped folder.')) {
        fetch('/skip_job/' + folderName, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showAlert(data.message, 'success');
                setTimeout(() => location.reload(), 1000);
            } else {
                showAlert('Error: ' + data.message, 'error');
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
        });
    }
}

function resetToQueued(folderName) {
    if (confirm('Reset this job to queued? This will move the original files back to the queue and remove generated files.')) {
        fetch('/reset_to_queued/' + folderName, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showAlert(data.message, 'success');
                setTimeout(() => location.reload(), 1000);
            } else {
                showAlert('Error: ' + data.message, 'error');
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
        });
    }
}

function showAlert(message, type) {
    const alertDiv = document.createElement('div');
    alertDiv.className = `alert alert-${type}`;
    
    // Check if message contains HTML (like <br> tags)
    if (message.includes('<br>') || message.includes('<')) {
        alertDiv.innerHTML = message;
    } else {
        alertDiv.textContent = message;
    }
    
    const container = document.querySelector('.container');
    const header = container.querySelector('.header');
    container.insertBefore(alertDiv, header.nextSibling);
    
    setTimeout(() => {
        alertDiv.remove();
    }, 5000);
}

function fetchJobEmails() {
    if (confirm('Fetch new job emails from LinkedIn alerts? This will pull recent job postings from your email.')) {
        // Show loading state
        const button = event.target.closest('.action-btn');
        const originalContent = button.innerHTML;
        button.innerHTML = '<div class="stat-icon action">‚è≥</div><div class="stat-content"><p>Fetching...</p></div>';
        button.disabled = true;
        
        // Show initial message
        showAlert('Starting to fetch job emails from LinkedIn alerts. This may take a moment...', 'success');
        
        fetch('/run_step1_queue', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Start polling for completion
                pollFetchProgress(button, originalContent);
            } else {
                showAlert('Error: ' + data.message, 'error');
                // Restore button state on error
                button.innerHTML = originalContent;
                button.disabled = false;
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
            // Restore button state on error
            button.innerHTML = originalContent;
            button.disabled = false;
        });
    }
}

function pollFetchProgress(button, originalContent) {
    let pollCount = 0;
    const maxPolls = 30; // 5 minutes max (30 * 10 seconds)
    
    function checkCompletion() {
        pollCount++;
        
        // Update progress message
        const elapsed = pollCount * 10;
        button.innerHTML = `<div class="stat-icon action">üìß</div><div class="stat-content"><p>Fetching... ${elapsed}s</p></div>`;
        showAlert(`Fetching job emails... (${elapsed} seconds elapsed)`, 'success');
        
        // Check if new jobs appeared by comparing queue count
        fetch('/get_queue_count')
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // For now, we'll assume completion after a reasonable time
                // In a real implementation, you might check for process completion differently
                if (pollCount >= 6) { // After 1 minute, assume completion
                    button.innerHTML = '<div class="stat-icon action">‚úÖ</div><div class="stat-content"><p>Completed!</p></div>';
                    showAlert('Job email fetching completed! Refreshing page to show new jobs...', 'success');
                    
                    // Restore button and refresh page after delay
                    setTimeout(() => {
                        button.innerHTML = originalContent;
                        button.disabled = false;
                        window.location.reload();
                    }, 2000);
                } else if (pollCount < maxPolls) {
                    // Continue polling
                    setTimeout(checkCompletion, 10000); // Poll every 10 seconds
                } else {
                    // Timeout - assume completion
                    button.innerHTML = '<div class="stat-icon action">‚è∞</div><div class="stat-content"><p>Timeout</p></div>';
                    showAlert('Fetch operation timed out. Please check manually if new jobs were added.', 'error');
                    
                    setTimeout(() => {
                        button.innerHTML = originalContent;
                        button.disabled = false;
                        window.location.reload();
                    }, 3000);
                }
            }
        })
        .catch(error => {
            console.error('Error checking completion:', error);
            // Continue polling despite error
            if (pollCount < maxPolls) {
                setTimeout(checkCompletion, 10000);
            } else {
                button.innerHTML = originalContent;
                button.disabled = false;
            }
        });
    }
    
    // Start polling after initial delay
    setTimeout(checkCompletion, 10000); // First check after 10 seconds
}

function processQueue() {
    if (confirm('Process all jobs in the queue? This will generate AI resumes and cover letters for all queued jobs. This may take several minutes.')) {
        // Show loading state
        const button = event.target.closest('.action-btn');
        const originalContent = button.innerHTML;
        button.innerHTML = '<div class="stat-icon action">‚è≥</div><div class="stat-content"><p>Starting...</p></div>';
        button.disabled = true;
        
        // Show initial message
        showAlert('Starting AI resume and cover letter generation. This may take several minutes...', 'success');
        
        fetch('/run_step2_generate', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Start polling for progress updates
                pollProcessProgress();
            } else {
                showAlert('Error: ' + data.message, 'error');
                // Restore button state on error
                button.innerHTML = originalContent;
                button.disabled = false;
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
            // Restore button state on error
            button.innerHTML = originalContent;
            button.disabled = false;
        });
    }
}

function pollProcessProgress() {
    const button = document.querySelector('.process-queue');
    let pollCount = 0;
    
    function checkProgress() {
        pollCount++;
        
        fetch('/get_step2_progress')
        .then(response => response.json())
        .then(data => {
            if (data.success && data.progress) {
                const progress = data.progress;
                
                if (progress.status === 'running') {
                    // Update button with progress
                    const percent = progress.progress_percent || 0;
                    const elapsed = pollCount * 2; // 2 second intervals
                    button.innerHTML = `<div class="stat-icon action">‚öôÔ∏è</div><div class="stat-content"><p>Processing... ${percent}%</p></div>`;
                    
                    // Update user with progress message
                    let message = `Processing jobs... ${percent}% complete (${elapsed}s elapsed)`;
                    if (progress.current_job_name) {
                        message += ` - Currently processing: ${progress.current_job_name}`;
                    }
                    showAlert(message, 'success');
                    
                    // Continue polling
                    setTimeout(checkProgress, 2000);
                } else if (progress.status === 'completed') {
                    // Process completed
                    button.innerHTML = '<div class="stat-icon action">‚úÖ</div><div class="stat-content"><p>Completed!</p></div>';
                    showAlert('Job processing completed successfully! Refreshing page to show results...', 'success');
                    
                    // Restore button and refresh page after delay
                    setTimeout(() => {
                        button.innerHTML = '<div class="stat-icon action">‚öôÔ∏è</div><div class="stat-content"><p>Process Queue</p></div>';
                        button.disabled = false;
                        window.location.reload();
                    }, 2000);
                } else if (progress.status === 'error') {
                    // Process failed
                    button.innerHTML = '<div class="stat-icon action">‚ùå</div><div class="stat-content"><p>Error</p></div>';
                    showAlert('Job processing failed: ' + (progress.error || 'Unknown error'), 'error');
                    
                    // Restore button after delay
                    setTimeout(() => {
                        button.innerHTML = '<div class="stat-icon action">‚öôÔ∏è</div><div class="stat-content"><p>Process Queue</p></div>';
                        button.disabled = false;
                    }, 3000);
                } else {
                    // Status is idle or unknown, continue polling for a bit
                    if (pollCount < 150) { // 5 minutes max
                        setTimeout(checkProgress, 2000);
                    } else {
                        // Timeout
                        button.innerHTML = '<div class="stat-icon action">‚è∞</div><div class="stat-content"><p>Timeout</p></div>';
                        showAlert('Processing operation timed out. Please check manually.', 'error');
                        
                        setTimeout(() => {
                            button.innerHTML = '<div class="stat-icon action">‚öôÔ∏è</div><div class="stat-content"><p>Process Queue</p></div>';
                            button.disabled = false;
                        }, 3000);
                    }
                }
            } else {
                // No progress data, continue polling for a bit
                if (pollCount < 150) {
                    setTimeout(checkProgress, 2000);
                } else {
                    button.innerHTML = '<div class="stat-icon action">‚öôÔ∏è</div><div class="stat-content"><p>Process Queue</p></div>';
                    button.disabled = false;
                }
            }
        })
        .catch(error => {
            console.error('Error checking progress:', error);
            // Continue polling despite error for a few more attempts
            if (pollCount < 10) {
                setTimeout(checkProgress, 2000);
            } else {
                // Stop polling on repeated errors and restore button
                button.innerHTML = '<div class="stat-icon action">‚öôÔ∏è</div><div class="stat-content"><p>Process Queue</p></div>';
                button.disabled = false;
                showAlert('Error monitoring progress. Process may still be running.', 'error');
            }
        });
    }
    
    // Start polling
    setTimeout(checkProgress, 1000);
}

function processJob(folderName) {
    if (confirm('Generate AI resume and cover letter for this job? This may take a few minutes.')) {
        // Get selected resume (with fallback)
        const resumeSelect = document.getElementById('resume-select');
        let selectedResumeValue = resumeSelect ? resumeSelect.value : '';
        
        // If no resume selected or error loading, use default
        if (!selectedResumeValue || selectedResumeValue === '' || resumeSelect.textContent.includes('Error')) {
            selectedResumeValue = 'Stephen_Hilton'; // Use default resume
            console.log('Using default resume: Stephen_Hilton');
        }
        
        console.log('Selected resume:', selectedResumeValue);
        
        // Show loading message
        showAlert('Starting AI resume generation for this job...', 'success');
        
        fetch('/process_single_job/' + folderName, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Show persistent progress indicator
                showProgressIndicator('AI Generation Started', data.message);
                // Start polling for progress
                pollSingleJobProgress();
            } else {
                showAlert('Error: ' + data.message, 'error');
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
        });
    }
}

function pollSingleJobProgress() {
    let pollCount = 0;
    const maxPolls = 120; // 4 minutes max (2 second intervals)
    
    function checkProgress() {
        pollCount++;
        
        fetch('/get_single_job_progress')
        .then(response => response.json())
        .then(data => {
            if (data.success && data.progress) {
                const progress = data.progress;
                
                if (progress.status === 'idle') {
                    // No processing in progress
                    hideProgressIndicator();
                    return;
                }
                
                // Update the progress indicator
                if (progress.status === 'running' || progress.status === 'starting') {
                    updateProgressIndicator('AI Generation In Progress', progress.message);
                    
                    // Continue polling if not completed and under max polls
                    if (!progress.completed && pollCount < maxPolls) {
                        setTimeout(checkProgress, 2000); // Poll every 2 seconds
                    } else if (pollCount >= maxPolls) {
                        updateProgressIndicator('Taking Longer Than Expected', 'Job processing is taking longer than expected. Please check back later or refresh the page.');
                        // Don't hide the indicator, let user know it's still running
                    }
                } else if (progress.status === 'completed') {
                    updateProgressIndicator('AI Generation Completed!', progress.message + ' Page will reload in 3 seconds.');
                    setTimeout(() => {
                        hideProgressIndicator();
                        location.reload();
                    }, 3000);
                } else if (progress.status === 'error') {
                    updateProgressIndicator('AI Generation Failed', 'Error: ' + progress.message);
                    // Keep the error visible for 10 seconds, then hide
                    setTimeout(() => {
                        hideProgressIndicator();
                    }, 10000);
                }
            } else {
                updateProgressIndicator('Progress Check Failed', 'Error checking progress: ' + (data.message || 'Unknown error'));
                setTimeout(() => {
                    hideProgressIndicator();
                }, 5000);
            }
        })
        .catch(error => {
            updateProgressIndicator('Progress Check Failed', 'Error checking progress: ' + error);
            setTimeout(() => {
                hideProgressIndicator();
            }, 5000);
        });
    }
    
    // Start checking progress after a short delay
    setTimeout(checkProgress, 1000);
}

// Auto-refresh functionality
let autoRefreshEnabled = true;
let autoRefreshInterval = null;

function startAutoRefresh() {
    if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
    }
    
    // Refresh every 15 seconds
    autoRefreshInterval = setInterval(() => {
        if (autoRefreshEnabled) {
            // Only refresh if no modals or progress indicators are visible
            const progressIndicator = document.getElementById('progress-indicator');
            const isProgressVisible = progressIndicator && progressIndicator.style.display !== 'none';
            
            if (!isProgressVisible) {
                console.log('Auto-refreshing page...');
                window.location.reload();
            }
        }
    }, 15000); // 15 seconds
}

function stopAutoRefresh() {
    autoRefreshEnabled = false;
    if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
    }
}

function toggleAutoRefresh() {
    autoRefreshEnabled = !autoRefreshEnabled;
    const button = document.getElementById('auto-refresh-toggle');
    if (button) {
        button.textContent = autoRefreshEnabled ? '‚è∏Ô∏è Pause Auto-Refresh' : '‚ñ∂Ô∏è Resume Auto-Refresh';
        button.title = autoRefreshEnabled ? 'Click to pause auto-refresh' : 'Click to resume auto-refresh';
    }
    
    if (autoRefreshEnabled) {
        startAutoRefresh();
    } else {
        stopAutoRefresh();
    }
}

// Start auto-refresh when page loads
document.addEventListener('DOMContentLoaded', function() {
    startAutoRefresh();
    
    // Add toggle button to the page
    const sidebar = document.querySelector('.sidebar');
    if (sidebar) {
        const toggleButton = document.createElement('button');
        toggleButton.id = 'auto-refresh-toggle';
        toggleButton.className = 'action-btn';
        toggleButton.textContent = '‚è∏Ô∏è Pause Auto-Refresh';
        toggleButton.title = 'Click to pause auto-refresh (refreshes every 15 seconds)';
        toggleButton.onclick = toggleAutoRefresh;
        toggleButton.style.marginTop = '10px';
        toggleButton.style.fontSize = '12px';
        
        sidebar.appendChild(toggleButton);
    }
});

// Pause auto-refresh when user is actively interacting
document.addEventListener('click', function() {
    // Temporarily pause auto-refresh for 30 seconds after user interaction
    if (autoRefreshEnabled) {
        stopAutoRefresh();
        setTimeout(() => {
            if (autoRefreshEnabled) {
                startAutoRefresh();
            }
        }, 30000); // Resume after 30 seconds of inactivity
    }
});
</script>

<script>
function markCommunications(folderName) {
    if (confirm('Mark this job as in communications? This will move it to the communications folder.')) {
        fetch('/mark_communications/' + folderName, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showAlert(data.message, 'success');
                setTimeout(() => location.reload(), 1000);
            } else {
                showAlert('Error: ' + data.message, 'error');
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
        });
    }
}

function markInterviewing(folderName) {
    if (confirm('Mark this job as interviewing? This will move it to the interviews folder.')) {
        fetch('/mark_interviewing/' + folderName, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showAlert(data.message, 'success');
                setTimeout(() => location.reload(), 1000);
            } else {
                showAlert('Error: ' + data.message, 'error');
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
        });
    }
}

function markExpired(folderName) {
    if (confirm('Mark this job as expired? This will move it to the expired folder.')) {
        fetch('/mark_expired/' + folderName, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showAlert(data.message, 'success');
                setTimeout(() => location.reload(), 1000);
            } else {
                showAlert('Error: ' + data.message, 'error');
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
        });
    }
}

function regenerateJob(folderName) {
    if (confirm('Regenerate AI resume and cover letter for this job? This may take a few minutes.')) {
        // Get selected resume
        const resumeSelect = document.getElementById('resume-select');
        const selectedResumeValue = resumeSelect ? resumeSelect.value : '';
        
        if (!selectedResumeValue) {
            alert('Please select a resume first.');
            return;
        }
        
        // Create form data to include selected resume
        const formData = new FormData();
        formData.append('selected_resume', selectedResumeValue);
        
        fetch('/regenerate_job/' + folderName, {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Show persistent progress indicator
                showProgressIndicator('AI Regeneration Started', data.message);
                // Start polling for progress
                pollJobRegenerationProgress();
            } else {
                showAlert('Error: ' + data.message, 'error');
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
        });
    }
}

function showProgressIndicator(title, message) {
    const indicator = document.getElementById('progress-indicator');
    const titleEl = document.getElementById('progress-title');
    const messageEl = document.getElementById('progress-message');
    
    if (indicator && titleEl && messageEl) {
        titleEl.textContent = title;
        messageEl.textContent = message;
        indicator.style.display = 'block';
        
        // Scroll to top to make sure user sees it
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
}

function updateProgressIndicator(title, message) {
    const titleEl = document.getElementById('progress-title');
    const messageEl = document.getElementById('progress-message');
    
    if (titleEl && messageEl) {
        titleEl.textContent = title;
        messageEl.textContent = message;
    }
}

function hideProgressIndicator() {
    const indicator = document.getElementById('progress-indicator');
    if (indicator) {
        indicator.style.display = 'none';
    }
}

function pollJobRegenerationProgress() {
    let pollCount = 0;
    const maxPolls = 120; // 4 minutes max (2 second intervals)
    
    function checkProgress() {
        pollCount++;
        
        fetch('/get_job_regeneration_progress')
        .then(response => response.json())
        .then(data => {
            if (data.success && data.progress) {
                const progress = data.progress;
                
                if (progress.status === 'idle') {
                    // No regeneration in progress
                    hideProgressIndicator();
                    return;
                }
                
                // Update the progress indicator
                if (progress.status === 'running' || progress.status === 'starting') {
                    updateProgressIndicator('AI Regeneration In Progress', progress.message);
                    
                    // Continue polling if not completed and under max polls
                    if (!progress.completed && pollCount < maxPolls) {
                        setTimeout(checkProgress, 2000); // Poll every 2 seconds
                    } else if (pollCount >= maxPolls) {
                        updateProgressIndicator('Taking Longer Than Expected', 'Job regeneration is taking longer than expected. Please check back later or refresh the page.');
                        // Don't hide the indicator, let user know it's still running
                    }
                } else if (progress.status === 'completed') {
                    updateProgressIndicator('AI Regeneration Completed!', progress.message + ' Page will reload in 3 seconds.');
                    setTimeout(() => {
                        hideProgressIndicator();
                        location.reload();
                    }, 3000);
                } else if (progress.status === 'error') {
                    updateProgressIndicator('AI Regeneration Failed', 'Error: ' + progress.message);
                    // Keep the error visible for 10 seconds, then hide
                    setTimeout(() => {
                        hideProgressIndicator();
                    }, 10000);
                }
            } else {
                updateProgressIndicator('Progress Check Failed', 'Error checking progress: ' + (data.message || 'Unknown error'));
                setTimeout(() => {
                    hideProgressIndicator();
                }, 5000);
            }
        })
        .catch(error => {
            updateProgressIndicator('Progress Check Failed', 'Error checking progress: ' + error);
            setTimeout(() => {
                hideProgressIndicator();
            }, 5000);
        });
    }
    
    // Start checking progress after a short delay
    setTimeout(checkProgress, 1000);
}

function regenerateHtmlOnly(folderName) {
    if (confirm('Regenerate HTML files (resume + cover letter) from existing content? This will update formatting without calling AI.')) {
        // Show loading message
        showAlert('Regenerating HTML files from existing content...', 'info');
        
        fetch('/regenerate_html_only/' + folderName, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showAlert('HTML files regenerated successfully! ' + (data.message || ''), 'success');
                // Refresh the page to show updated files
                setTimeout(() => {
                    location.reload();
                }, 2000);
            } else {
                showAlert('Error regenerating HTML files: ' + (data.message || 'Unknown error'), 'danger');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            showAlert('Error regenerating HTML files: ' + error.message, 'danger');
        });
    }
}

function regenerateJobPdfs(folderName) {
    if (confirm('Regenerate PDF files for this job? This will replace existing PDFs with new ones generated from the current HTML files.')) {
        // Show loading message
        showAlert('Starting PDF regeneration for this job...', 'success');
        
        fetch('/regenerate_job_pdfs/' + folderName, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showAlert(data.message, 'success');
                setTimeout(() => {
                    window.location.reload();
                }, 2000);
            } else {
                // Handle multi-line error messages
                const errorMessage = data.message.replace(/\n/g, '<br>');
                showAlert('Error: ' + errorMessage, 'error');
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
        });
    }
}

function markApplied(folderName) {
    if (confirm('Mark this job as applied? This will move it to the applied folder.')) {
        fetch('/mark_applied/' + folderName, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showAlert(data.message, 'success');
                setTimeout(() => location.reload(), 1000);
            } else {
                showAlert('Error: ' + data.message, 'error');
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
        });
    }
}

function skipJob(folderName) {
    if (confirm('Skip this job? This will move it to the skipped folder.')) {
        fetch('/skip_job/' + folderName, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showAlert(data.message, 'success');
                setTimeout(() => location.reload(), 1000);
            } else {
                showAlert('Error: ' + data.message, 'error');
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
        });
    }
}

function resetToQueued(folderName) {
    if (confirm('Reset this job to queued? This will move the original files back to the queue and remove generated files.')) {
        fetch('/reset_to_queued/' + folderName, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showAlert(data.message, 'success');
                setTimeout(() => location.reload(), 1000);
            } else {
                showAlert('Error: ' + data.message, 'error');
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
        });
    }
}

function showAlert(message, type) {
    const alertDiv = document.createElement('div');
    alertDiv.className = `alert alert-${type}`;
    
    // Check if message contains HTML (like <br> tags)
    if (message.includes('<br>') || message.includes('<')) {
        alertDiv.innerHTML = message;
    } else {
        alertDiv.textContent = message;
    }
    
    const container = document.querySelector('.container');
    const header = container.querySelector('.header');
    container.insertBefore(alertDiv, header.nextSibling);
    
    setTimeout(() => {
        alertDiv.remove();
    }, 5000);
}

function fetchJobEmails() {
    if (confirm('Fetch new job emails from LinkedIn alerts? This will pull recent job postings from your email.')) {
        // Show loading state
        const button = event.target.closest('.action-btn');
        const originalContent = button.innerHTML;
        button.innerHTML = 'Fetching...';
        button.disabled = true;
        
        // Show initial message
        showAlert('Starting to fetch job emails from LinkedIn alerts. This may take a moment...', 'success');
        
        fetch('/run_step1_queue', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Start polling for completion
                pollFetchProgress(button, originalContent);
            } else {
                showAlert('Error: ' + data.message, 'error');
                // Restore button state on error
                button.innerHTML = originalContent;
                button.disabled = false;
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
            // Restore button state on error
            button.innerHTML = originalContent;
            button.disabled = false;
        });
    }
}

function pollFetchProgress(button, originalContent) {
    let pollCount = 0;
    const maxPolls = 30; // 5 minutes max (30 * 10 seconds)
    
    function checkCompletion() {
        pollCount++;
        
        // Update progress message
        const elapsed = pollCount * 10;
        button.innerHTML = `Fetching... ${elapsed}s`;
        showAlert(`Fetching job emails... (${elapsed} seconds elapsed)`, 'success');
        
        // Check if new jobs appeared by comparing queue count
        fetch('/get_queue_count')
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // For now, we'll assume completion after a reasonable time
                // In a real implementation, you might check for process completion differently
                if (pollCount >= 6) { // After 1 minute, assume completion
                    button.innerHTML = 'Completed!';
                    showAlert('Job email fetching completed! Refreshing page to show new jobs...', 'success');
                    
                    // Restore button and refresh page after delay
                    setTimeout(() => {
                        button.innerHTML = originalContent;
                        button.disabled = false;
                        window.location.reload();
                    }, 2000);
                } else if (pollCount < maxPolls) {
                    // Continue polling
                    setTimeout(checkCompletion, 10000); // Poll every 10 seconds
                } else {
                    // Timeout - assume completion
                    button.innerHTML = 'Timeout';
                    showAlert('Fetch operation timed out. Please check manually if new jobs were added.', 'error');
                    
                    setTimeout(() => {
                        button.innerHTML = originalContent;
                        button.disabled = false;
                        window.location.reload();
                    }, 3000);
                }
            }
        })
        .catch(error => {
            console.error('Error checking completion:', error);
            // Continue polling despite error
            if (pollCount < maxPolls) {
                setTimeout(checkCompletion, 10000);
            } else {
                button.innerHTML = originalContent;
                button.disabled = false;
            }
        });
    }
    
    // Start polling after initial delay
    setTimeout(checkCompletion, 10000); // First check after 10 seconds
}

function processQueue() {
    if (confirm('Process all jobs in the queue? This will generate AI resumes and cover letters for all queued jobs. This may take several minutes.')) {
        // Show loading state
        const button = event.target.closest('.process-queue-btn');
        const originalContent = button.innerHTML;
        button.innerHTML = '<div class="process-icon">‚è≥</div><div class="process-text">Starting...</div>';
        button.disabled = true;
        
        // Show initial message
        showAlert('Starting to process all jobs in the queue. This may take several minutes...', 'success');
        
        fetch('/run_step2_generate', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Start polling for progress updates
                pollProcessProgress();
            } else {
                showAlert('Error: ' + data.message, 'error');
                // Restore button state on error
                button.innerHTML = originalContent;
                button.disabled = false;
            }
        })
        .catch(error => {
            showAlert('Error: ' + error, 'error');
            // Restore button state on error
            button.innerHTML = originalContent;
            button.disabled = false;
        });
    }
}

function pollProcessProgress() {
    const button = document.querySelector('.process-queue-btn');
    let pollCount = 0;
    
    function checkProgress() {
        pollCount++;
        
        fetch('/get_step2_progress')
        .then(response => response.json())
        .then(data => {
            if (data.success && data.progress) {
                const progress = data.progress;
                
                if (progress.status === 'running') {
                    // Update button with progress
                    const percent = progress.progress_percent || 0;
                    const elapsed = pollCount * 2; // 2 second intervals
                    button.innerHTML = `<div class="process-icon">‚öôÔ∏è</div><div class="process-text">Processing... ${percent}%</div>`;
                    
                    // Update user with progress message
                    let message = `Processing jobs... ${percent}% complete (${elapsed}s elapsed)`;
                    if (progress.current_job_name) {
                        message += ` - Currently processing: ${progress.current_job_name}`;
                    }
                    showAlert(message, 'success');
                    
                    // Continue polling
                    setTimeout(checkProgress, 2000);
                } else if (progress.status === 'completed') {
                    // Process completed
                    button.innerHTML = '<div class="process-icon">‚úÖ</div><div class="process-text">Completed!</div>';
                    showAlert('Job processing completed successfully! Refreshing page to show results...', 'success');
                    
                    // Restore button and refresh page after delay
                    setTimeout(() => {
                        button.innerHTML = '<div class="process-icon">‚öôÔ∏è</div><div class="process-text">Process All Jobs in Queue</div>';
                        button.disabled = false;
                        window.location.reload();
                    }, 2000);
                } else if (progress.status === 'error') {
                    // Process failed
                    button.innerHTML = '<div class="process-icon">‚ùå</div><div class="process-text">Error</div>';
                    showAlert('Job processing failed: ' + (progress.error || 'Unknown error'), 'error');
                    
                    // Restore button after delay
                    setTimeout(() => {
                        button.innerHTML = '<div class="process-icon">‚öôÔ∏è</div><div class="process-text">Process All Jobs in Queue</div>';
                        button.disabled = false;
                    }, 3000);
                } else {
                    // Status is idle or unknown, continue polling for a bit
                    if (pollCount < 150) { // 5 minutes max
                        setTimeout(checkProgress, 2000);
                    } else {
                        // Timeout
                        button.innerHTML = '<div class="process-icon">‚è∞</div><div class="process-text">Timeout</div>';
                        showAlert('Processing operation timed out. Please check manually.', 'error');
                        
                        setTimeout(() => {
                            button.innerHTML = '<div class="process-icon">‚öôÔ∏è</div><div class="process-text">Process All Jobs in Queue</div>';
                            button.disabled = false;
                        }, 3000);
                    }
                }
            } else {
                // No progress data, continue polling for a bit
                if (pollCount < 150) {
                    setTimeout(checkProgress, 2000);
                } else {
                    button.innerHTML = '<div class="process-icon">‚öôÔ∏è</div><div class="process-text">Process All Jobs in Queue</div>';
                    button.disabled = false;
                }
            }
        })
        .catch(error => {
            console.error('Error checking progress:', error);
            // Continue polling despite error for a few more attempts
            if (pollCount < 10) {
                setTimeout(checkProgress, 2000);
            } else {
                // Stop polling on repeated errors and restore button
                button.innerHTML = '<div class="process-icon">‚öôÔ∏è</div><div class="process-text">Process All Jobs in Queue</div>';
                button.disabled = false;
                showAlert('Error monitoring progress. Process may still be running.', 'error');
            }
        });
    }
    
    // Start polling
    setTimeout(checkProgress, 1000);
}
</script>
{% endblock %}